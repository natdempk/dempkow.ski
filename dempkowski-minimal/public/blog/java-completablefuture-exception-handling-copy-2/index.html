<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
<title>Java&#39;s CompleteableFuture exception handling: whenComplete vs. handle | Nat Dempkowski</title>

    <link rel="stylesheet" href="/css/main.css">
  <link
    rel="stylesheet"
    href="/css/rose-pine-dawn.min.css"
  />


      <script src="/js/main.js"></script>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
  <script>hljs.highlightAll();</script>


</head>
<body>
  <header>
    <div>
      <h1><a href="/">Nat Dempkowski</a></h1>


    </div>
  </header>
  <main class="content-wrapper">
    <article class="content-container">
      
  <h1>Java&#39;s CompleteableFuture exception handling: whenComplete vs. handle</h1>

  
  
  <time datetime="2017-10-20T23:00:15-04:00">October 20, 2017</time>

  <p>Today I learned about the behavior of thrown exceptions within asynchronous code using Java&rsquo;s CompletableFutures.</p>
<p>The question I had was:</p>
<blockquote>
<p>Is it possible to have a CompletableFuture which calls something like <code>.handle()</code>, but returns <code>Void</code>?</p>
</blockquote>
<p>I was writing code that wanted to basically handle exceptional cases, but not propagate those exceptions outwards.</p>
<p>I had written something like:</p>
<div class="highlight language-java"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>CompletableFuture.<span style="color:#a6e22e">supplyAsync</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException();
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">handle</span>((i, err) <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (err <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException(err);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(i);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">join</span>();
</span></span></code></pre></div><p>And since <code>handle</code> is defined as taking in a <code>BiFunction: (T, Throwable) -&gt; U</code>:</p>
<div class="highlight language-java"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">handle</span>(BiFunction<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> T,Throwable,<span style="color:#f92672">?</span> <span style="color:#66d9ef">extends</span> U<span style="color:#f92672">&gt;</span> fn)
</span></span></code></pre></div><p>We&rsquo;re stuck with an unnecessary <code>return i</code> in our code, even though we don&rsquo;t care about the result of the <code>handle</code>. In this case we&rsquo;re just logging on success. The question was then raised:</p>
<blockquote>
<p>Why not use <code>whenComplete</code>?</p>
</blockquote>
<p>Whose signature looks like:</p>
<div class="highlight language-java"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>CompletableFuture<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">whenComplete</span>(BiConsumer<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> T,<span style="color:#f92672">?</span> <span style="color:#66d9ef">super</span> Throwable<span style="color:#f92672">&gt;</span> action)
</span></span></code></pre></div><p>And well, for one that doesn&rsquo;t actually solve my problem, as I still need to return something out of the <code>whenComplete</code>, but it also raised the question of what would happen in the exceptional case, and why do these two seemingly similar methods even exist?</p>
<p>The answer here is somewhat that they handle errors differently. If we look at the <em>totally clear</em> JavaDocs for <code>handle</code>:</p>
<blockquote>
<p>When this stage is complete, the given function is invoked with the result (or null if none) and the exception (or null if none) of this stage as arguments, and the function&rsquo;s result is used to complete the returned stage.</p>
</blockquote>
<p>and for <code>whenComplete</code>:</p>
<blockquote>
<p>When this stage is complete, the given action is invoked with the result (or null if none) and the exception (or null if none) of this stage as arguments. The returned stage is completed when the action returns. If the supplied action itself encounters an exception, then the returned stage exceptionally completes with this exception unless this stage also completed exceptionally.</p>
</blockquote>
<p>It&rsquo;s totally clear what happens right? I mean from reading those two blurbs I&rsquo;m sure you could easily predict the result of this snippet:</p>
<div class="highlight language-java"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>CompletableFuture.<span style="color:#a6e22e">supplyAsync</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException(<span style="color:#e6db74">&#34;1&#34;</span>);
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">whenComplete</span>((i, err) <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>  System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException(<span style="color:#e6db74">&#34;2&#34;</span>);
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">join</span>();
</span></span></code></pre></div><p>You might assume that you&rsquo;d get back <code>RuntimeException(&quot;2&quot;)</code> since thats the last thing thrown in the chain, and it seems like <code>whenComplete</code> takes in an error, so that&rsquo;s probably not just hanging around, right? Well, if we run the code we see:</p>
<div class="highlight language-java"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>hello
</span></span><span style="display:flex;"><span>Exception in thread <span style="color:#e6db74">&#34;main&#34;</span> java.<span style="color:#a6e22e">util</span>.<span style="color:#a6e22e">concurrent</span>.<span style="color:#a6e22e">CompletionException</span>: java.<span style="color:#a6e22e">lang</span>.<span style="color:#a6e22e">RuntimeException</span>: 1
</span></span><span style="display:flex;"><span>	at java.<span style="color:#a6e22e">util</span>.<span style="color:#a6e22e">concurrent</span>.<span style="color:#a6e22e">CompletableFuture</span>.<span style="color:#a6e22e">encodeThrowable</span>(CompletableFuture.<span style="color:#a6e22e">java</span>:273)
</span></span><span style="display:flex;"><span>	at java.<span style="color:#a6e22e">util</span>.<span style="color:#a6e22e">concurrent</span>.<span style="color:#a6e22e">CompletableFuture</span>.<span style="color:#a6e22e">completeThrowable</span>(CompletableFuture.<span style="color:#a6e22e">java</span>:280)
</span></span><span style="display:flex;"><span>	at java.<span style="color:#a6e22e">util</span>.<span style="color:#a6e22e">concurrent</span>.<span style="color:#a6e22e">CompletableFuture$AsyncSupply</span>.<span style="color:#a6e22e">run</span>(CompletableFuture.<span style="color:#a6e22e">java</span>:1592)
</span></span></code></pre></div><p>What even happened here to see this output? We see <code>hello</code>, so we know that the code from the <code>whenComplete</code> block executed, but that exception looks like it&rsquo;s from the <code>supplyAsync</code> call. So not only did our second exception simply disappear, but <code>whenComplete</code> also wrapped our inital exception in a <code>CompletionException</code>. Fantastic.</p>
<p>Imagine if we had wanted to handle that error somehow, and done something like:</p>
<div class="highlight language-java"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>CompletableFuture.<span style="color:#a6e22e">supplyAsync</span>(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException(<span style="color:#e6db74">&#34;1&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> 1;
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">whenComplete</span>((i, err) <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (err <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException(err.<span style="color:#a6e22e">getMessage</span>());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">join</span>();
</span></span></code></pre></div><p>Well again, all we&rsquo;re going to get back is our original exception:</p>
<div class="highlight language-java"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Exception in thread <span style="color:#e6db74">&#34;main&#34;</span> java.<span style="color:#a6e22e">util</span>.<span style="color:#a6e22e">concurrent</span>.<span style="color:#a6e22e">CompletionException</span>: java.<span style="color:#a6e22e">lang</span>.<span style="color:#a6e22e">RuntimeException</span>: 1
</span></span></code></pre></div><p>So what did we learn?</p>
<ol>
<li>There doesn&rsquo;t seem to be a great way to handle exceptions while returning <code>CompletableFuture&lt;Void&gt;</code></li>
<li>If we want to actually handle any errors specially, we need to use <code>handle</code> which explicitly doesn&rsquo;t propagate errors for us, instead allowing us to take action on errors explicitly. This means we can either squash them, or propagate changed versions of them.</li>
<li><code>CompletionException</code>s are basically going to spring up in our code when using <code>CompletableFuture</code>s and there&rsquo;s not a whole lot we can do about it, besides liberally using <code>handle</code>? We can also use <code>exceptionally</code> to deal with this problem, but we can save that for another post.</li>
</ol>

  


    <section>
      <p>Copyright 2025. All rights reserved.</p>


    </section>
    </article>
  </main>
</body>
</html>
